<script>
  const state = {
    settings: null,
    rolling: { dateFrom: null, dateTo: null, items: [] },
    planItems: [],
    week: { weekStart: null, weekEnd: null, items: [], totals: null },
    stats: null,
       weekAnchorDate: null,
    currentView: 'today',
    modal: { open: false, item: null },
    auth: { sessionToken: localStorage.getItem('sessionToken') || null, user: null, needsSetup: false, strava: null },
    planImport: { headers: [], rows: [], preview: null },
    activities: { items: [] },
    statsUi: { rangeWeeks: 12, granularity: 'week' }
  };

  const el = (id) => document.getElementById(id);

  function init(){
    wireBottomNav();
    wireModal();
    wireTopbar();
    wireAuth();
    wirePlanTools();
    checkAuthAndStart();
  }

  function wireTopbar(){
    el('refreshBtn').addEventListener('click', () => bootstrapAll(true));
   el('resumeBackfillBtn').addEventListener('click', async () => {
      try {
        await apiCall('apiResumeStravaBackfill', {});
        toast('Backfill resumed');
        await refreshStravaStatus();
      } catch (err) {
        console.error(err);
        toast('Unable to resume backfill');
      }
    });
    el('restartBackfillBtn').addEventListener('click', async () => {
      try {
        await apiCall('apiRestartStravaBackfill', {});
        toast('Backfill restarted');
        await refreshStravaStatus();
      } catch (err) {
        console.error(err);
        toast('Unable to restart backfill');
      }
    });
  el('connectStravaBtn').addEventListener('click', async () => {
      try {
        if (state.auth.strava?.connected) {
          await apiCall('apiDisconnectStrava', {});
          state.auth.strava = { connected:false };
          updateStravaButton();
          toast('Strava disconnected');
          await refreshStravaStatus();
          return;
        }
        const res = await apiCall('apiGetStravaConnectUrl', {});
        if (res?.url) {
          const win = window.open(res.url, '_blank', 'noopener,noreferrer');
          if (!win) window.location.href = res.url;
        }
      } catch(err){
        console.error(err);
         toast(err && err.message ? `Strava connect failed: ${err.message}` : 'Unable to start Strava connect');
      }
    });
  }

  function wireBottomNav(){
    document.querySelectorAll('.nav-item').forEach(btn => {
      btn.addEventListener('click', () => switchView(btn.dataset.view));
    });
  }

  function switchView(view){
    state.currentView = view;

    document.querySelectorAll('.nav-item').forEach(b => {
      b.classList.toggle('active', b.dataset.view === view);
    });

    el('view-today').classList.toggle('hidden', view !== 'today');
    el('view-plan').classList.toggle('hidden', view !== 'plan');
    el('view-activities').classList.toggle('hidden', view !== 'activities');
    el('view-stats').classList.toggle('hidden', view !== 'stats');

    renderActive();
  }

  function setSubtitle(text){
    el('subTitle').textContent = text;
  }

  function toast(msg){
    const t = el('toast');
    t.textContent = msg;
    t.classList.remove('hidden');
    setTimeout(() => t.classList.add('hidden'), 1600);
  }

   
  async function checkAuthAndStart(){
    try {
      const res = await callRaw('apiGetAuthState', { sessionToken: state.auth.sessionToken });
      state.auth.needsSetup = !!res.needsSetup;
      if (!res.authenticated) {
        showAuthOverlay(res.needsSetup);
        return;
      }
      state.auth.user = res.user;
      state.auth.strava = res.strava || { connected:false };
      el('appTitle').textContent = `Training Planner${res.user?.displayName ? ' • ' + res.user.displayName : ''}`;
      updateStravaButton();
      hideAuthOverlay();
      bootstrapAll();
    } catch (err) {
      console.error(err);
      showAuthOverlay(false);
    }
  }

  function wireAuth(){
    el('authSubmitBtn').addEventListener('click', async () => {
      const payload = {
        email: el('authEmail').value,
        password: el('authPassword').value,
        displayName: el('authDisplayName').value
      };
      try {
        const res = state.auth.needsSetup
          ? await callRaw('apiCreateAdmin', payload)
          : await callRaw('apiLogin', payload);
        state.auth.sessionToken = res.sessionToken;
        localStorage.setItem('sessionToken', state.auth.sessionToken);
        hideAuthOverlay();
        hideResetPasswordPanel();
        await checkAuthAndStart();
      } catch (err) {
        const msg = String(err && err.message || '').replace('Error: ', '');
        toast(msg ? `Login failed: ${msg}` : 'Login failed');
      }
    });

    el('authResetToggleBtn').addEventListener('click', () => {
      const showing = !el('authResetPanel').classList.contains('hidden');
      if (showing) hideResetPasswordPanel();
      else showResetPasswordPanel();
    });

    el('authResetSubmitBtn').addEventListener('click', async () => {
      const email = String(el('authResetEmail').value || '').trim();
      const newPassword = String(el('authResetPassword').value || '');
      if (!email || !newPassword) {
        toast('Enter email and new password');
        return;
      }
      try {
        await callRaw('apiResetPassword', { email, newPassword });
        toast('Password reset. Please login.');
        hideResetPasswordPanel();
        el('authEmail').value = email;
        el('authPassword').value = '';
      } catch (err) {
        const msg = String(err && err.message || '').replace('Error: ', '');
        toast(msg ? `Reset failed: ${msg}` : 'Reset failed');
      }
    });
  }

  function showAuthOverlay(needsSetup){
    state.auth.needsSetup = !!needsSetup;
    el('authTitle').textContent = needsSetup ? 'Create Admin' : 'Login';
    el('authMeta').textContent = needsSetup ? 'First run setup' : 'Sign in to continue';
    el('authNameLabel').classList.toggle('hidden', !needsSetup);
    el('authDisplayName').classList.toggle('hidden', !needsSetup);
    el('authResetToggleBtn').classList.toggle('hidden', !!needsSetup);
    if (needsSetup) hideResetPasswordPanel();
    el('authOverlay').classList.remove('hidden');
  }

  function hideAuthOverlay(){ el('authOverlay').classList.add('hidden'); }
 function showResetPasswordPanel(){ el('authResetPanel').classList.remove('hidden'); }
  function hideResetPasswordPanel(){ el('authResetPanel').classList.add('hidden'); }

  function updateStravaButton(){
    const b = el('connectStravaBtn');
    const connected = !!state.auth.strava?.connected;
    b.textContent = connected ? 'Disconnect Strava' : 'Connect Strava';
  
    const status = el('stravaStatusBadge');
    const resumeBtn = el('resumeBackfillBtn');
    const restartBtn = el('restartBackfillBtn');
    if (!connected) {
      status.classList.add('hidden');
      status.textContent = '';
      resumeBtn.classList.add('hidden');
      restartBtn.classList.add('hidden');
      return;
    }

    const done = !!state.auth.strava?.backfillDone;
    const mode = state.auth.strava?.backfillMode || 'beforeCursor';
    const page = Number(state.auth.strava?.backfillPage || 1);
    const before = Number(state.auth.strava?.backfillBeforeEpoch || 0);
    const cursorDate = before ? new Date(before * 1000).toISOString().slice(0, 10) : 'n/a';
    status.classList.remove('hidden');
    status.textContent = done
      ? 'Backfill complete'
      : `Backfill in progress: ${mode === 'page' ? `page ${page}` : `before ${cursorDate}`}`;
    resumeBtn.classList.remove('hidden');
    restartBtn.classList.remove('hidden');
  }

  async function refreshStravaStatus(){
    if (!state.auth.sessionToken) return;
    try {
      const strava = await apiCall('apiGetStravaStatus', {});
      state.auth.strava = strava || { connected:false };
      updateStravaButton();
    } catch (err) {
      console.error(err);
    }
  }


  function wirePlanTools(){
    el('planImportCloseBtn').addEventListener('click', closePlanImportModal);
    el('planGenerateCloseBtn').addEventListener('click', closePlanGenerateModal);
    el('planImportOverlay').addEventListener('click', (e) => { if (e.target === el('planImportOverlay')) closePlanImportModal(); });
    el('planGenerateOverlay').addEventListener('click', (e) => { if (e.target === el('planGenerateOverlay')) closePlanGenerateModal(); });

    el('planImportPreviewBtn').addEventListener('click', async () => {
      try {
        const file = el('planImportFile').files?.[0];
        if (!file) { toast('Pick a CSV file first'); return; }
        const text = await file.text();
        const parsed = parseCsvText(text);
        state.planImport.headers = parsed.headers;
        state.planImport.rows = parsed.rows;

        const preview = await apiCall('planImportPreview', {
          headers: parsed.headers,
          rows: parsed.rows
        });
        state.planImport.preview = preview;
        renderPlanImportPreview(preview);
        el('planImportCommitBtn').disabled = !!preview.criticalErrorCount;
      } catch (err) {
        console.error(err);
        toast('Preview failed');
      }
    });

    el('planImportCommitBtn').addEventListener('click', async () => {
      try {
        if (!state.planImport.preview) { toast('Run preview first'); return; }
        const res = await apiCall('planImportCommit', {
          headers: state.planImport.headers,
          rows: state.planImport.rows
        });
        toast(`Imported ${res.total} rows (${res.inserted} new, ${res.updated} updated)`);
        closePlanImportModal();
        bootstrapAll(true);
      } catch (err) {
        console.error(err);
        toast('Import failed');
      }
    });

    el('planGenerateCommitBtn').addEventListener('click', async () => {
      try {
        const payload = {
          planName: el('genPlanName').value,
          targetDistanceKm: Number(el('genTargetKm').value || 10),
          planLengthWeeks: Number(el('genLengthWeeks').value || 12),
          trainingDaysPerWeek: Number(el('genDaysPerWeek').value || 4),
          longRunDay: el('genLongRunDay').value,
          startDate: el('genStartDate').value || '',
          includeIntervals: !!el('genIncludeIntervals').checked,
          includeTempo: !!el('genIncludeTempo').checked
        };
        const res = await apiCall('planGenerateCommit', payload);
        el('planGenerateSummary').textContent = `Generated ${res.total} rows (${res.inserted} new, ${res.updated} updated), PlanID ${res.planId}`;
        toast('Plan generated');
        bootstrapAll(true);
      } catch (err) {
        console.error(err);
        toast('Generate failed');
      }
    });
  }

  function openPlanImportModal(){
    el('planImportOverlay').classList.remove('hidden');
    el('planImportSummary').textContent = 'Upload CSV and click Preview.';
    el('planImportPreviewWrap').innerHTML = '';
    el('planImportCommitBtn').disabled = true;
  }
  function closePlanImportModal(){ el('planImportOverlay').classList.add('hidden'); }
  function openPlanGenerateModal(){
    el('planGenerateOverlay').classList.remove('hidden');
    el('planGenerateSummary').textContent = '';
  }
  function closePlanGenerateModal(){ el('planGenerateOverlay').classList.add('hidden'); }

  function renderPlanImportPreview(preview){
    const warnCount = (preview.issues || []).reduce((a,it)=>a+(it.warnings||[]).length,0);
    const errCount = Number(preview.criticalErrorCount || 0);
    el('planImportSummary').innerHTML = `Rows: ${(preview.normalizedRows||[]).length} • <span class="chip-warn">Warnings: ${warnCount}</span> • <span class="chip-err">Errors: ${errCount}</span>`;

    const sample = preview.sample || [];
    if (!sample.length) {
      el('planImportPreviewWrap').innerHTML = '<div class="hero-sub">No rows parsed.</div>';
      return;
    }

    const cols = ['PlanID','PlanName','Date','SportType','WorkoutType','PlannedKm','PlannedMin','Notes'];
    const table = `
      <table class="preview-table">
        <thead><tr>${cols.map(c => `<th>${esc(c)}</th>`).join('')}</tr></thead>
        <tbody>
          ${sample.map(r => `<tr>${cols.map(c => `<td>${esc(r[c] ?? '')}</td>`).join('')}</tr>`).join('')}
        </tbody>
      </table>`;

    const issueTop = (preview.issues || []).filter(it => (it.warnings?.length || it.errors?.length)).slice(0, 8)
      .map(it => `<div class="hero-sub">Row ${it.rowNumber}: ${(it.errors||[]).join('; ')} ${(it.warnings||[]).join('; ')}</div>`).join('');

    el('planImportPreviewWrap').innerHTML = table + (issueTop ? `<div style="margin-top:8px;">${issueTop}</div>` : '');
  }

  function parseCsvText(text){
    const rows = [];
    let cur = '';
    let row = [];
    let inQ = false;
    for (let i=0;i<text.length;i++) {
      const ch = text[i];
      const nxt = text[i+1];
      if (ch === '"') {
        if (inQ && nxt === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        row.push(cur.trim());
        cur = '';
      } else if ((ch === '\n' || ch === '\r') && !inQ) {
        if (ch === '\r' && nxt === '\n') i++;
        row.push(cur.trim());
        if (row.some(v => v !== '')) rows.push(row);
        row = [];
        cur = '';
      } else {
        cur += ch;
      }
    }
    if (cur.length || row.length) {
      row.push(cur.trim());
      if (row.some(v => v !== '')) rows.push(row);
    }
    const headers = rows.length ? rows[0] : [];
    return { headers, rows: rows.slice(1) };
  }


/** -------------------------
   * Bootstrap
   * ------------------------*/
  async function bootstrapAll(force){
    setSubtitle('Loading…');

    try {
      const res = await apiCall('apiBootstrap', {});
      state.settings = res.settings;
      state.rolling = { dateFrom: res.dateFrom, dateTo: res.dateTo, items: res.items };

      setSubtitle('Your training week');
      refreshStravaStatus();

      const [planRes, activitiesRes] = await Promise.all([
        apiCall('apiListPlan', {}),
        apiCall('apiListActivities', { limit: 200 })
      ]);
      state.planItems = planRes?.items || [];
      state.activities.items = activitiesRes?.items || [];

      bootstrapWeek(todayIsoLocal());
      bootstrapStats();
      renderActive();
    } catch (err) {
      console.error(err);
      setSubtitle('Load failed');
      toast('Load failed');
    }
  }

  function bootstrapWeek(anchorDate){
    const anchor = anchorDate || state.weekAnchorDate || todayIsoLocal();
    google.script.run
      .withSuccessHandler(res => {
        state.week = { weekStart: res.weekStart, weekEnd: res.weekEnd, items: res.items, totals: res.totals };
        state.weekAnchorDate = res.weekStart || anchor;
        if (state.currentView === 'plan' || state.currentView === 'today') renderActive();
      })
      .withFailureHandler(err => console.error(err))
      .apiComputeWeek(withSession({ anchorDate: anchor }));
  }

  function changeWeek(offset){
    const base = state.week?.weekStart || todayIsoLocal();
    const d = new Date(base + 'T00:00:00');
    d.setDate(d.getDate() + (Number(offset) * 7));
    bootstrapWeek(localDateISO(d));
  }

  function bootstrapStats(){
     const today = todayIsoLocal();
    const from = new Date();
    from.setDate(from.getDate() - (state.statsUi.rangeWeeks * 7));
    const dateFrom = localDateISO(from);

    google.script.run
      .withSuccessHandler(res => {
        state.stats = res;
        if (state.currentView === 'stats' || state.currentView === 'today') renderActive();
      })
      .withFailureHandler(err => console.error(err))
     apiComputeStats(withSession({ dateFrom, dateTo: today, granularity: state.statsUi.granularity }));
  }

  /** -------------------------
   * Render dispatcher
   * ------------------------*/
  function renderActive(){
    if (state.currentView === 'today') renderToday();
    if (state.currentView === 'plan') renderPlan();
    if (state.currentView === 'activities') renderActivities();
    if (state.currentView === 'stats') renderStats();
  }

  /** -------------------------
   * View: Today
   * ------------------------*/
  function renderToday(){
     const root = el('view-today');
    const todayISO = todayIsoLocal();

    const todayItems = state.rolling.items.filter(it => it.Date === todayISO);
    const nextItems = state.rolling.items
      .filter(it => it.Date > todayISO)
      .sort((a,b) => (a.Date.localeCompare(b.Date) || (a.Slot||'').localeCompare(b.Slot||'')))
      .slice(0, 6);

    // Week progress (if week data loaded)
    const wk = state.week?.items || [];
    const wkPlanned = wk.length;
    const wkDone = wk.filter(it => it.Log && (it.Log.Status === 'DONE' || it.Log.Status === 'PARTIAL')).length;
    const pct = wkPlanned ? Math.round((wkDone / wkPlanned) * 100) : 0;

    root.innerHTML = `
      <div class="hero">
        <div class="hero-top">
          <div>
            <div class="hero-title">Week</div>
           <div class="hero-sub">${formatDateShort(todayISO)} • ${todayItems.length} session(s)</div>
          </div>
         <div class="hero-sub">${state.week?.weekStart ? `Week ${formatDateShort(state.week.weekStart)} → ${formatDateShort(state.week.weekEnd)}` : ''}</div>
        </div>

        <div class="bar"><div style="width:${pct}%"></div></div>

        <div class="hero-kpis">
          <div class="kpi"><div class="k">Week progress</div><div class="v">${wkDone}/${wkPlanned || 0}</div></div>
          <div class="kpi"><div class="k">Planned km (week)</div><div class="v">${fmt1(state.week?.totals?.plannedKm || 0)}</div></div>
          <div class="kpi"><div class="k">Done km (week)</div><div class="v">${fmt1(state.week?.totals?.doneKm || 0)}</div></div>
        </div>
      </div>

      <div class="section-title">Today sessions</div>
      ${renderSessionCardBlock(todayItems, { showEmpty: true, allowDone: true })}

      <div class="section-title">Up next</div>
       ${renderSessionCardBlock(nextItems, { showEmpty: false, showDate: true, actions: 'none' })}

       <div class="section-title">Add activity</div>
      <div class="tile-grid">
        <div class="tile run" data-add="run"><small>Add</small><span>Run</span></div>
        <div class="tile swim" data-add="swim"><small>Add</small><span>Swim</span></div>
        <div class="tile bike" data-add="bike"><small>Add</small><span>Bike</span></div>
        <div class="tile workout" data-add="workout"><small>Add</small><span>Workout</span></div>
      </div>

      <div class="section-title">Streaks</div>
      ${renderStreakMini()}
    `;

    wireSessions(root);
    wireAddTiles(root);
  }

  function renderStreakMini(){
    const s = state.stats;
    const a = s?.streaks?.allPlannedCompleted ?? 0;
    const b = s?.streaks?.didSomething ?? 0;
    const allowance = Number(s?.settings?.PartialAllowancePerWeek ?? 1);

    return `
      <div class="card">
        <div class="card-pad">
          <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div class="kpi" style="flex:1 1 200px;">
              <div class="k">All planned completed</div>
              <div class="v">${a}</div>
              <div class="hero-sub">Allows ${allowance} partial/week</div>
            </div>
            <div class="kpi" style="flex:1 1 200px;">
              <div class="k">Did something</div>
              <div class="v">${b}</div>
              <div class="hero-sub">Any done/partial</div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  /** -------------------------
   * View: Plan (All sessions)
   * ------------------------*/
  function renderPlan(){
    const root = el('view-plan');

    const items = (state.planItems || []).slice().sort((a,b) => (a.Date.localeCompare(b.Date) || (a.Slot||'').localeCompare(b.Slot||'')));
    const grouped = groupByDateSlot(items);

    const totals = state.week?.totals || computeTotalsClient(items);
    const plannedCount = items.length;
    const doneCount = items.filter(it => it.Log && (it.Log.Status === 'DONE' || it.Log.Status === 'PARTIAL')).length;
    const pct = plannedCount ? Math.round((doneCount/plannedCount)*100) : 0;

     const weekLabel = `${items.length} total session(s)`;

    root.innerHTML = `
       <div class="week-card">
        <div class="week-top">
          <div>
            <div class="week-title">Plan</div>
            <div class="week-meta">${weekLabel} • ${doneCount}/${plannedCount} done • ${fmt1(totals.plannedKm)} km planned</div>
            <div class="bar"><div style="width:${pct}%"></div></div>
          </div>
             <div style="display:flex; gap:8px; align-items:center;">
               <button class="btn ghost" data-action="add-activity" style="min-width:auto;">Add Activity</button>
              <button class="btn ghost" data-action="open-import" style="min-width:auto;">Add Plan</button>
            <button class="btn primary" data-action="open-generate" style="min-width:auto;">Create Plan</button>
                      </div>
        </div>

        <div class="card" id="week1Body" style="margin-top:12px;">
          ${Object.keys(grouped).sort().map(dateISO => {
            const day = grouped[dateISO];
            return `
              <div class="card-pad" style="padding-bottom:0;">
                <div class="section-title" style="margin:0 0 8px 0;">${formatDateWithDay(dateISO)}</div>
              </div>
              ${renderSlotList(dateISO, 'AM', day.AM)}
              ${renderSlotList(dateISO, 'PM', day.PM)}
            `;
          }).join('')}
        </div>
      </div>
    `;

    wireSessions(root);
    root.querySelector('[data-action="add-activity"]')?.addEventListener('click', () => {
      toast('Add activity flow coming next');
    });
   root.querySelector('[data-action="open-import"]')?.addEventListener('click', openPlanImportModal);
    root.querySelector('[data-action="open-generate"]')?.addEventListener('click', openPlanGenerateModal);
  }

  function renderSlotList(dateISO, slot, items){
    items = items || [];
    if (!items.length) return '';
    return `
      <div class="card-pad" style="padding-top:6px; padding-bottom:6px; border-top:1px solid rgba(255,255,255,.06);">
        <div class="section-title" style="margin:0; font-size:12px;">${slot}</div>
      </div>
      ${items.map(it => renderSessionRow(it, { allowDone:false })).join('')}
    `;
  }


  /** -------------------------
   * View: Activities (completed feed)
   * ------------------------*/
  function renderActivities(){
    const root = el('view-activities');

   const acts = (state.activities.items || []).slice();

    root.innerHTML = `
      <div class="section-title">Activities</div>
      <div class="card">
          ${acts.length ? acts.map(renderActivityRow).join('') :
          `<div class="card-pad"><div class="hero-sub">No synced activities yet. Connect Strava and run backfill.</div></div>`
        }
      </div>
    `;
}

    function renderActivityRow(it){
    const km = num(it.distanceM) / 1000;
    const min = Math.round(num(it.movingTimeS) / 60);
    const elev = fmt0(num(it.totalElevationGainM));
    const dateLabel = formatDateWithDay(String(it.startDate || '').slice(0, 10));
    const details = [
      it.type || 'Activity',
      km ? `${fmt1(km)} km` : '',
      min ? `${fmt0(min)} min` : '',
      elev && elev !== '0' ? `${elev} m↑` : ''
    ].filter(Boolean).join(' • ');
    const title = it.name || it.type || 'Activity';
    return `
      <div class="session" style="cursor:default;">
        <div class="dot" style="background:${workoutColor({ Sport: it.type })};"></div>
        <div class="session-main">
          <div class="session-title">${esc(title)}</div>
          <div class="session-sub">${esc(`${dateLabel} • ${details}`)}</div>
        </div>
      </div>
    `;
  }

  /** -------------------------
   * View: Stats (full)
   * ------------------------*/
  function renderStats(){
    const root = el('view-stats');
    const res = state.stats;

    const s1 = res?.streaks?.allPlannedCompleted ?? 0;
    const s2 = res?.streaks?.didSomething ?? 0;
    const allowance = Number(res?.settings?.PartialAllowancePerWeek ?? 1);

    root.innerHTML = `
      <div class="section-title">Stats</div>

<div class="card" style="margin-bottom:12px;">
        <div class="card-pad" style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
          <label class="field" style="margin:0; min-width:220px;">
            <span>Range</span>
            <select id="statsRangeSel">
              <option value="4" ${state.statsUi.rangeWeeks === 4 ? 'selected' : ''}>Last 4 weeks</option>
              <option value="12" ${state.statsUi.rangeWeeks === 12 ? 'selected' : ''}>Last 12 weeks</option>
              <option value="26" ${state.statsUi.rangeWeeks === 26 ? 'selected' : ''}>Last 26 weeks</option>
              <option value="52" ${state.statsUi.rangeWeeks === 52 ? 'selected' : ''}>Last 52 weeks</option>
            </select>
          </label>
          <label class="field" style="margin:0; min-width:220px;">
            <span>Group by</span>
            <select id="statsGranularitySel">
              <option value="week" ${state.statsUi.granularity === 'week' ? 'selected' : ''}>Per week</option>
              <option value="month" ${state.statsUi.granularity === 'month' ? 'selected' : ''}>Per month</option>
            </select>
          </label>
        </div>
      </div>

      <div class="card">
        <div class="card-pad">
          <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div class="kpi" style="flex:1 1 220px;">
              <div class="k">Streak: all planned</div>
              <div class="v">${s1}</div>
              <div class="hero-sub">Allows ${allowance} partial/week</div>
            </div>
            <div class="kpi" style="flex:1 1 220px;">
              <div class="k">Streak: did something</div>
              <div class="v">${s2}</div>
              <div class="hero-sub">Any done/partial with actuals</div>
            </div>
          </div>

          <div style="height:10px;"></div>

                    <div style="display:flex; gap:12px; flex-wrap:wrap;">
            <div class="kpi" style="flex:1 1 220px;">
              <div class="k">Km this month</div>
              <div class="v">${fmt1(res?.kmSummary?.monthDoneKm || 0)}</div>
            </div>
            <div class="kpi" style="flex:1 1 220px;">
              <div class="k">Km this year</div>
              <div class="v">${fmt1(res?.kmSummary?.yearDoneKm || 0)}</div>
       </div>
          </div>

          <div style="margin-top:12px;">
            <div class="k" style="font-size:28px; color:var(--muted); font-weight:900;">Distance trend</div>
            ${renderTrendChart(res?.distanceTrend || [], state.statsUi.granularity)}
          </div>
        </div>
      </div>
    `;
  
    el('statsRangeSel')?.addEventListener('change', (e) => {
      state.statsUi.rangeWeeks = Number(e.target.value || 12);
      bootstrapStats();
    });
    el('statsGranularitySel')?.addEventListener('change', (e) => {
      state.statsUi.granularity = e.target.value || 'week';
      bootstrapStats();
    });
  }

  function renderTrendChart(points, granularity){
    if (!points || !points.length) {
      return `<div class="hero-sub">No distance data in selected range.</div>`;
    }
    const maxKm = Math.max(...points.map(p => num(p.km)), 1);
    const bars = points.map(p => {
      const height = Math.max(6, Math.round((num(p.km) / maxKm) * 120));
      const label = granularity === 'month' ? String(p.label || '').slice(2) : String(p.label || '').slice(5);
      return `
        <div style="flex:1 1 0; min-width:28px; text-align:center;">
          <div style="height:130px; display:flex; align-items:flex-end; justify-content:center;">
            <div title="${esc(p.label)}: ${fmt1(num(p.km))} km" style="width:100%; max-width:34px; height:${height}px; border-radius:8px 8px 4px 4px; background:linear-gradient(180deg, rgba(59,130,246,.95), rgba(37,99,235,.85));"></div>
          </div>
          <div style="font-size:20px; color:var(--muted); margin-top:4px;">${esc(label)}</div>
          <div style="font-size:20px;">${fmt1(num(p.km))}</div>
        </div>
      `;
    }).join('');
    return `<div style="display:flex; gap:8px; align-items:flex-end; overflow:auto; padding-top:8px;">${bars}</div>`;
  }

  /** -------------------------
   * Session rendering
   * ------------------------*/
  function renderSessionCardBlock(items, options){
    const showEmpty = !!options?.showEmpty;
    const showDate = !!options?.showDate;
    const allowDone = options?.allowDone !== false;
    const actions = options?.actions || 'default';
    if (!items || !items.length){
      return showEmpty ? `<div class="card"><div class="card-pad"><div class="hero-sub">No sessions.</div></div></div>` : '';
    }
    return `
      <div class="card">
          ${items.map(it => renderSessionRow(it, { showDate, allowDone, actions })).join('')}
      </div>
    `;
  }

  function renderSessionRow(it, options){
    options = (options && typeof options === "object") ? options : {};
    const showDate = !!options?.showDate;
    const allowDone = options?.allowDone !== false;
    const actions = options?.actions || 'default';
    const log = it.Log || null;
    const status = log?.Status || 'PLANNED';

    const color = workoutColor(it);
    const planned = plannedText(it);
    const actual = log ? actualText(log) : '';

    let rightBtn = '';
    if (actions !== 'none') {
      rightBtn = (status === 'DONE' || status === 'PARTIAL' || status === 'SKIPPED' || !allowDone)
        ? `<button class="btn ghost" data-action="edit" data-planid="${esc(it.PlanID)}">Edit</button>`
        : `<button class="btn primary" data-action="done" data-planid="${esc(it.PlanID)}">Done</button>`;
    }

    const dateLine = showDate ? `${formatDateWithDay(it.Date)} • ` : '';
    const sub = `${dateLine}${it.Slot || ''} • ${it.Sport || 'Other'} • ${planned}${it.RPE ? ` • RPE ${esc(String(it.RPE))}` : ''}`;

    return `
      <div class="session" data-planid="${esc(it.PlanID)}">
        <div class="dot" style="background:${color};"></div>
        <div class="session-main">
          <div class="session-title">${esc(it.Title || '(Untitled)')}</div>
          <div class="session-sub">${esc(sub)}</div>
          ${it.Notes ? `<div class="session-note">${esc(it.Notes)}</div>` : ''}
          ${actual ? `<div class="session-note">Actual: ${esc(actual)}</div>` : ''}
        </div>
        <div class="session-actions">
          ${rightBtn}
        </div>
      </div>
    `;
  }

  function wireSessions(root){
    // done buttons
    root.querySelectorAll('button[data-action="done"]').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const planId = e.currentTarget.dataset.planid;
        e.currentTarget.disabled = true;
        try{
          const log = await callApiSetDone({ planId });
          patchItemLog(planId, log);
          toast('Marked done');
         bootstrapWeek(todayIsoLocal());   // refresh totals
          bootstrapStats();  // refresh streaks
          renderActive();
        }catch(err){
          console.error(err);
          toast('Failed');
        }finally{
          e.currentTarget.disabled = false;
        }
      });
    });

    // edit buttons
    root.querySelectorAll('button[data-action="edit"]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const planId = e.currentTarget.dataset.planid;
        const item = findItem(planId);
        if (item) openModal(item);
      });
    });

    // tap row to edit
    root.querySelectorAll('.session').forEach(row => {
      row.addEventListener('click', (e) => {
        if (e.target.closest('button')) return;
        const planId = row.dataset.planid;
        const item = findItem(planId);
        if (item) openModal(item);
      });
    });
  }

  function wireAddTiles(root){
    root.querySelectorAll('[data-add]').forEach(tile => {
      tile.addEventListener('click', () => {
        const activity = tile.dataset.add;
        toast(`Add ${activity} activity (next step)`);
        // v1.1: open "create planned session" modal and write to Plan
      });
    });
  }

  /** -------------------------
   * Modal
   * ------------------------*/
  function wireModal(){
    el('modalCloseBtn').addEventListener('click', closeModal);
    el('modalCancelBtn').addEventListener('click', closeModal);
    el('modalOverlay').addEventListener('click', (e) => {
      if (e.target === el('modalOverlay')) closeModal();
    });

    el('modalSaveBtn').addEventListener('click', async () => {
      const item = state.modal.item;
      if (!item) return;

      const payload = {
        planId: item.PlanID,
        status: el('editStatus').value,
        actualKm: el('editKm').value,
        actualMin: el('editMin').value,
        notes: el('editNotes').value
      };

      el('modalSaveBtn').disabled = true;
      try{
        const log = await callApiUpdateLog(payload);
        patchItemLog(item.PlanID, log);
        toast('Updated');
        closeModal();
         bootstrapWeek(todayIsoLocal());
        bootstrapStats();
        renderActive();
      }catch(err){
        console.error(err);
        toast('Save failed');
      }finally{
        el('modalSaveBtn').disabled = false;
      }
    });
  }

  function openModal(item){
    state.modal.open = true;
    state.modal.item = item;

    el('modalTitle').textContent = item.Title || 'Edit session';
    el('modalMeta').textContent = `${formatDateShort(item.Date)} • ${item.Slot} • ${item.Sport || 'Other'}`;

    const log = item.Log || null;

    el('editStatus').value = (log?.Status || 'DONE');
    el('editKm').value = (log?.ActualKm ?? item.PlannedKm ?? '');
    el('editMin').value = (log?.ActualMin ?? item.PlannedMin ?? '');
    el('editNotes').value = (log?.LogNotes ?? '');

    el('modalOverlay').classList.remove('hidden');
    el('modalOverlay').setAttribute('aria-hidden', 'false');
  }

  function closeModal(){
    state.modal.open = false;
    state.modal.item = null;
    el('modalOverlay').classList.add('hidden');
    el('modalOverlay').setAttribute('aria-hidden', 'true');
  }

  /** -------------------------
   * Data helpers
   * ------------------------*/
  function groupByDateSlot(items){
    const out = {};
    (items || []).forEach(it => {
      const d = it.Date;
      if (!out[d]) out[d] = { AM: [], PM: [], count: 0 };
      const slot = (it.Slot || 'AM').toUpperCase();
      if (slot === 'PM') out[d].PM.push(it);
      else out[d].AM.push(it);
      out[d].count++;
    });
    // sort within slots
    Object.keys(out).forEach(d => {
      out[d].AM.sort(sortItem);
      out[d].PM.sort(sortItem);
    });
    return out;
  }

  function sortItem(a,b){
    return (String(a.Slot||'').localeCompare(String(b.Slot||'')) ||
            String(a.Sport||'').localeCompare(String(b.Sport||'')) ||
            String(a.Title||'').localeCompare(String(b.Title||'')));
  }

  function findItem(planId){
    const pool = [...(state.planItems||[]), ...(state.rolling.items||[]), ...(state.week.items||[])];
    return pool.find(x => x.PlanID === planId);
  }

  function patchItemLog(planId, log){
    const patch = (arr) => {
      const idx = arr.findIndex(x => x.PlanID === planId);
      if (idx >= 0) arr[idx].Log = log || null;
    };
    patch(state.rolling.items);
    patch(state.week.items || []);
  }

  function computeTotalsClient(items){
    const t = { plannedKm:0, plannedMin:0, doneKm:0, doneMin:0 };
    (items||[]).forEach(it => {
      t.plannedKm += num(it.PlannedKm);
      t.plannedMin += num(it.PlannedMin);
      const log = it.Log;
      if (log && (log.Status === 'DONE' || log.Status === 'PARTIAL')){
        t.doneKm += num(log.ActualKm);
        t.doneMin += num(log.ActualMin);
      }
    });
    return t;
  }

  /** -------------------------
   * Workout colour logic
   * ------------------------*/
  function workoutColor(it){
    const sport = (it.Sport || '').toLowerCase();
    const title = (it.Title || '').toLowerCase();

    if (sport.includes('swim')) return 'var(--swim)';
    if (sport.includes('bike') || sport.includes('cycle')) return 'var(--bike)';
    if (sport.includes('gym')) return 'var(--gym)';
    if (sport.includes('mob')) return 'var(--mob)';

    // Running type by title keywords
    if (title.includes('easy')) return 'var(--easy)';
    if (title.includes('tempo')) return 'var(--tempo)';
    if (title.includes('interval')) return 'var(--interval)';
    if (title.includes('hill')) return 'var(--hills)';
    if (title.includes('long') || title.includes('peak')) return 'var(--long)';
    if (title.includes('race')) return 'var(--race)';

    return 'rgba(255,255,255,.18)';
  }

  function plannedText(it){
    const mode = String(it.MetricMode || 'BOTH').toUpperCase();
    const km = num(it.PlannedKm);
    const min = num(it.PlannedMin);

    if (mode === 'KM') return `${fmt1(km)} km`;
    if (mode === 'MIN') return `${fmt0(min)} min`;
    const parts = [];
    if (km) parts.push(`${fmt1(km)} km`);
    if (min) parts.push(`${fmt0(min)} min`);
    return parts.join(' • ') || '—';
  }

  function actualText(log){
    const ak = num(log.ActualKm);
    const am = num(log.ActualMin);
    const parts = [];
    if (ak) parts.push(`${fmt1(ak)} km`);
    if (am) parts.push(`${fmt0(am)} min`);
    return `${log.Status}: ${parts.join(' • ') || '—'}`;
  }


  function localDateISO(d){
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  function todayIsoLocal(){
    return localDateISO(new Date());
  }

function formatDateShort(dateISO){
    if (!dateISO) return '';
    const y = String(dateISO).slice(2,4);
    const m = String(dateISO).slice(5,7);
    const dNum = String(dateISO).slice(8,10);
    return `${dNum}-${m}-${y}`;
  }

function formatDateWithDay(dateISO){
    if (!dateISO) return '';
    const d = new Date(dateISO + 'T00:00:00');
    const day = d.toLocaleDateString('en-US', { weekday: 'short' });
    return `${day} ${formatDateShort(dateISO)}`;
  }

  function fmt1(n){
    const r = Math.round(n*10)/10;
    return (Math.abs(r)%1===0) ? String(r.toFixed(0)) : String(r.toFixed(1));
  }
  function fmt0(n){ return String(Math.round(num(n))); }
  function num(v){ const n = Number(v); return isNaN(n) ? 0 : n; }

  function esc(s){
    return String(s || '')
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'","&#039;");
  }

  /** -------------------------
   * Server calls
   * ------------------------*/
 function withSession(payload){
    return { ...(payload || {}), sessionToken: state.auth.sessionToken };
  }

  function callRaw(method, payload){
    return new Promise((resolve, reject) => {
   google.script.run.withSuccessHandler(resolve).withFailureHandler(reject)[method](payload || {});
    });
  }

  async function apiCall(method, payload){
    try {
      return await callRaw(method, withSession(payload));
    } catch (err) {
      const msg = String(err && err.message || err || '');
      if (msg.includes('Session expired') || msg.includes('Authentication required')) {
        localStorage.removeItem('sessionToken');
        state.auth.sessionToken = null;
        showAuthOverlay(false);
      }
      throw err;
    }
  }

  function callApiSetDone(payload){
    return apiCall('apiSetDone', payload);
  }

  function callApiUpdateLog(payload){
     return apiCall('apiUpdateLog', payload);
  }

  // boot
  init();
</script>
